# ORM, 영속성 컨텍스트, 엔티티 메니저

## 날짜: 2025-03-18

### 스크럼
- 학습 목표 1 :

### 오늘의 도전 과제와 해결 방법
- 

### 새로 배운 내용
# ORM

(Object-Relational Mapping)

객체를 관계형 디비와 자동으로 매핑해주는 기술

## JPA

자바에서 ORM을 구현하기 위한 표준 명세

- 엔티티와 테이블 간 매핑 규칙 @Entity, @Table, @Id
- 영속성 컨텍스트 개념
- 트랜잭션/쿼리 처리 방식 등

<한계>

- SQL만큼 유연하지 X  →  복잡한 쿼리를 쓸 때는 어려워서 그냥 native query 사용

### @Enumerated

자바의 enum 타입을 관리

- EnumType.ORDINAL  :  순서로 관리  →  사용 금지..
- EnumType.STRING  :  스트링으로 관리

<aside>
🎀

**영속성(Persistence)**

데이터를 생성한 프로그램이 종료되어도 사라지지 않는 데이터의 특성 → 영구 저장

**컨텍스트(context)**

코드의 배경이 되는 조건, 환경 정도

</aside>

## 영속성 컨텍스트

엔티티(객체)는 영속성 컨텍스트라는 공간 안에서 관리된다.

엔티티는 생명 주기를 갖는다.

- 1차 캐시
    - 동일 트랜잭션 안에서 같은 PK 엔티티를 재조회 시 db 대신 캐시에서 반환
    - 동일 트랜잭션 안에서 같은 PK 엔티티를 재조회 시 `SELECT` 쿼리 추가 실행 X  →  동일성 보장!
    
    <aside>
    🎀
    
    트랜잭션(Transaction)
    
    디비의 상태를 변화시키기 위해 수행하는 작업의 단위
    
    SQL(`SELECT`, `INSERT`, `DELETE`, `UPDATE`)를 하나 이상 이용해서 디비에 접근하는 것
    
    </aside>
    
- Dirty Checking(변경 감지):   엔티티 속성 변경을 추적해서 트랜잭션 커밋 시점에 `UPDATE` SQL 자동 수행
- Lazy Loading(지연 로딩):   연관관계가 설정된 엔티티를 실제 필요 시점에 DB로 부터 가져옴
- Write-behind(쓰기 지연):   `INSERT`, `UPDATE` SQL을 모아놨다가 커밋 시 일괄 처리 시도

→ 트랜잭션 범위 내에서 동작한다. @Transacional

→ 영속성 컨텍스트가 끝나면 1차 캐시도 종료된다.

### 영속성 컨텍스트 생명주기

비영속→영속→준영속→삭제

**비영속(Transient)**

- 영속성 컨텍스트와 무관 (단순히 `new`로 객체만 만든 상태)

**영속(Managed)**

- `persist()` 등으로 영속 컨텍스트에 등록된 상태
- 1차 캐시, 변경 감지, 지연 로딩 등이 적용됨

**준영속(Detached)**

- 한때 영속이었으나, 영속성 컨텍스트에서 분리됨 (`em.detach(entity)`, `em.clear()`, 트랜잭션 종료 등)
- 더 이상 변경 감지/로딩 지원받지 못함

**삭제(Removed)**

- `remove()`로 삭제 요청된 상태, 커밋 시 실제 DB에서 제거

## 엔티티 매니저

= API

엔티티를 영속성 컨텍스트에 등록&조회&수정&삭제 등 디비 작업을 수행하는 객체

= 내부적으로 **영속성 컨텍스트를 관리**하고 엔티티 상태를 제어

→ 스레드 세이프 X ⇒ 공유해서 사용하면 안 됨

## 트랜잭션 관리

- **Propagation**(전파 레벨) : 이미 진행중인 트랜직션이 있을때 현재 메소드를 어떻게 트랜잭션에 참여시킬 수 있을지를 결정하는 옵션.
- **Isolation**(격리 레벨)

## 지연 로딩과 즉시 로딩

### 지연 로딩(Lazy Loading)

FetchType.LAZY

연관된 엔티티를 실제 사용 시점에 디비 조회

<장>

- 초기 로딩 시 불필요한 디비 접근 X

<단>

- N+1 문제 발생

<aside>
🎀

**N+1 문제**

연관 객체 다수 로딩 시, 많은 `SELECT` 실행

</aside>

### 즉시 로딩(Eager Loading)

FetchType.EAGER

연관된 엔티티를 엔티티 조회 시점에 미리 조회

<장>

- 추가 쿼리 없어 편리
- 연관관계가 있지만 자주 묶어서 조회하는 경우 이득

<단>

- N+1 문제 발생
- 불필요한 쿼리 발생 가능

<aside>
🎀

**쿼리(Query)**

디비에 정보 요청하기

</aside>

### 오늘의 회고
- 

### 참고 자료 및 링크

