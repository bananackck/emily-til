# RDB, SQL, erd

## 날짜: 2025-03-04

### 스크럼
- 학습 목표 1 :

### 오늘의 도전 과제와 해결 방법
- 

### 새로 배운 내용
# RDB

<사용 이유>

데이터를 테이블 체계로 저장하여 데이터의 안정성과 신뢰성을 보장하기 위함

ex) 엑셀

# RDBMS

관계형 데이터 베이스

 = 서로 연관된 데이터를 테이블 형태로 저장하고 제공하는 DB

- 처음 설계가 중요하다.

| **Type Name** | **Description** | **Data Example** |
| --- | --- | --- |
| **BOOLEAN** | true 또는 false일 수 있는 bool 값 | true |
| **INT** | **정수 값을 저장하는 데 사용됩니다** | 1 |
| **FLOAT** | 3.14, 2.71828 등과 같은 부동 소수점 숫자 | 3.14 |
| **VARCHAR(n)** | 'hello world', '안녕 세계' 등과 같은
가변 길이 문자열을 저장하는 데 사용됩니다. 
"n"은 최대 문자열 길이를 의미하며, 실제로 필요한 만큼만 공간을 차지합니다. | hello world |
| **CHAR(n)** | **고정 길이 문자열을 저장하는 데 사용됩니다. 
"n"은 고정된 최대 문자열 길이입니다.** | hello world |
| **TEXT** | 최대 65,535자 길이의 더 긴 문자열. |  |
| **DATE** | YYYY-MM-DD 형식으로 날짜 값
범위 : '1000-01-01'에서 '9999-12-31'까지 | 2023-12-31 |
| **DATETIME** | YYYY-MM-DD HH:MI:SS 형식으로 날짜 및 시간 값 형식

범위 : '1000-01-01 00:00:00'에서 '9999-12-31 23:59:59’까지
- 유효 기간 같은거 | 2024-01-01 01:12:00 |
| **TIMESTAMP** | time_zone이라는 시스템 변수로 저장된 값을 기본으로 함

범위 : '1970-01-01 00:00:01' UTC부터 '2038-01-19 03:14:07' UTC

UTC란 전 세계 시간대를 조정하고 시계를 동기화하는 데 사용되는 글로벌 시간 표준
한국 표준시(KST)는 협정 세계시(UTC)보다 9시간 빠름.

예) UTC 기준 오후 12시면 KST는 오후 9시
UTC 기준 오전 3시면 KST는 오후 12시

장점 : 날짜를 따로 입력안해도 row 추가시 자동으로 입력이 가능

row 추가한 시간을 자동으로 알 수 있다. 예) 게시글 업로드 시간
- 설계 시간 같은 거 | 2024-08-23 21:06:53 |

<사용 방법>

- SQL을 사용한다.

<aside>
📌

DBMS

# RDB

<사용 이유>

데이터를 테이블 체계로 저장하여 데이터의 안정성과 신뢰성을 보장하기 위함

ex) 엑셀

# RDBMS

관계형 데이터 베이스

 = 서로 연관된 데이터를 테이블 형태로 저장하고 제공하는 DB

- 처음 설계가 중요하다.

| **Type Name** | **Description** | **Data Example** |
| --- | --- | --- |
| **BOOLEAN** | true 또는 false일 수 있는 bool 값 | true |
| **INT** | **정수 값을 저장하는 데 사용됩니다** | 1 |
| **FLOAT** | 3.14, 2.71828 등과 같은 부동 소수점 숫자 | 3.14 |
| **VARCHAR(n)** | 'hello world', '안녕 세계' 등과 같은
가변 길이 문자열을 저장하는 데 사용됩니다. 
"n"은 최대 문자열 길이를 의미하며, 실제로 필요한 만큼만 공간을 차지합니다. | hello world |
| **CHAR(n)** | **고정 길이 문자열을 저장하는 데 사용됩니다. 
"n"은 고정된 최대 문자열 길이입니다.** | hello world |
| **TEXT** | 최대 65,535자 길이의 더 긴 문자열. |  |
| **DATE** | YYYY-MM-DD 형식으로 날짜 값
범위 : '1000-01-01'에서 '9999-12-31'까지 | 2023-12-31 |
| **DATETIME** | YYYY-MM-DD HH:MI:SS 형식으로 날짜 및 시간 값 형식

범위 : '1000-01-01 00:00:00'에서 '9999-12-31 23:59:59’까지
- 유효 기간 같은거 | 2024-01-01 01:12:00 |
| **TIMESTAMP** | time_zone이라는 시스템 변수로 저장된 값을 기본으로 함

범위 : '1970-01-01 00:00:01' UTC부터 '2038-01-19 03:14:07' UTC

UTC란 전 세계 시간대를 조정하고 시계를 동기화하는 데 사용되는 글로벌 시간 표준
한국 표준시(KST)는 협정 세계시(UTC)보다 9시간 빠름.

예) UTC 기준 오후 12시면 KST는 오후 9시
UTC 기준 오전 3시면 KST는 오후 12시

장점 : 날짜를 따로 입력안해도 row 추가시 자동으로 입력이 가능

row 추가한 시간을 자동으로 알 수 있다. 예) 게시글 업로드 시간
- 설계 시간 같은 거 | 2024-08-23 21:06:53 |

<사용 방법>

- SQL을 사용한다.

<aside>
📌

DBMS

</aside>

<aside>
📌

ORM

</aside>

### 정규화

: 제대로 된 상태를 만드는 것

= RDB의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스

→ 데이터를 안정적이게 & 중복 최소화 하기 위해 테이블을 관리하는 프로세스(가이드라인)

<사용 이유>

1. **무결성 유지**
    
    데이터가 일관적이고 신뢰할 수 있는 데이터관리
    
2. 저장 용량 줄이기
    
    데이터 중복이 많으면 저장 용량이 많아진다…
    

<잘 안됬을 때 문제점>

1. 삽입 이상 : 불필요하거나 알 수 없는 정보를 강제로 같이 입력해야 하는 경우
    
    → 테이블 분리가 안되서 그렇다… null로 채워넣거나…(근데 이건 별로!!!! 사용 금지는 아닌데 대부분 추천 안함.)
    
    <aside>
    📌
    
    null이란?
    
    사용이유?
    
    지양이유?
    
    </aside>
    
2. 삭제 이상 : 원하지 않는 관련된 정보까지 함께 삭제
3. 갱신 이상 : 데이터 중복으로 인해 데이터를 갱신할 때 일관성이 없어짐

⇒ 이와 같은 이상현상을 없애기 위해서 “테이블 나누는 작업=정규화”가 필요하다.

but, 너무 많이 나누면 관리가 어렵고 성능이 떨어짐.

종류는 1NF ~ 5NF 까지. (+반 정규화도 있다.)

## 제 1정규형(1NF)

테이블이 가장 기본적인 정리 단계에 있는 상태

- 모든 열은 원자값을 가져야 하고, (= 하나의 칼럼에 하나의 값만)
- 각 열의 값은 간단하고 분할할 수 없는 하나의 정보만을 포함해야 합니다.

## 제 2정규형(2NF)

함수 종속성

- 한 테이블에 중복되는 값이 많이 있을 때 테이블을 분리한다.
- ~~한 칼럼이 다른 칼럼의 값에 의존할 때~~

## 제 3정규형(3NF)

어떤 속성도 기본 키에만 직접적으로 종속되어야 한다. + 다른 non-key 속성에 의존해서는 안 됨!

# SQL

데이터베이스 언어

## DCL

사용자에게 권한 부여

### JOIN

테이블 결합

- inner-join : 실로 사용되기로는 그냥 조인
- left-join : 조인 조건에 만족하는 오른쪽 칼럼만 조인 (없으면 null)
- right-join
- outer-join
- 프라우터 조인: 모든 레코드 포함하고 조인 조건에 만족하지 않으면 ㄴㄴ (mySQL에서 직접 지원 ㄴㄴ)

<단>

잘못된 조인은 성능 저하

### VIEW

데이터 보는 방식 제공.

실제로 저장된 테이블은 아니고, 쿼리 결과가ㅏ 테이블처럼 제공된다.

UNION

sql 쿼리문으 ㅣ결과를 합침

# erd

디비 안에 한 눈에 파악할 수 있도록 도와주는 도구

<aside>
📌

엔티티

</aside>

</aside>

<aside>
📌

ORM

</aside>

### 정규화

: 제대로 된 상태를 만드는 것

= RDB의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스

→ 데이터를 안정적이게 & 중복 최소화 하기 위해 테이블을 관리하는 프로세스(가이드라인)

<사용 이유>

1. **무결성 유지**
    
    데이터가 일관적이고 신뢰할 수 있는 데이터관리
    
2. 저장 용량 줄이기
    
    데이터 중복이 많으면 저장 용량이 많아진다…
    

<잘 안됬을 때 문제점>

1. 삽입 이상 : 불필요하거나 알 수 없는 정보를 강제로 같이 입력해야 하는 경우
    
    → 테이블 분리가 안되서 그렇다… null로 채워넣거나…(근데 이건 별로!!!! 사용 금지는 아닌데 대부분 추천 안함.)
    
    <aside>
    📌
    
    null이란?
    
    사용이유?
    
    지양이유?
    
    </aside>
    
2. 삭제 이상 : 원하지 않는 관련된 정보까지 함께 삭제
3. 갱신 이상 : 데이터 중복으로 인해 데이터를 갱신할 때 일관성이 없어짐

⇒ 이와 같은 이상현상을 없애기 위해서 “테이블 나누는 작업=정규화”가 필요하다.

but, 너무 많이 나누면 관리가 어렵고 성능이 떨어짐.

종류는 1NF ~ 5NF 까지. (+반 정규화도 있다.)

## 제 1정규형(1NF)

테이블이 가장 기본적인 정리 단계에 있는 상태

- 모든 열은 원자값을 가져야 하고, (= 하나의 칼럼에 하나의 값만)
- 각 열의 값은 간단하고 분할할 수 없는 하나의 정보만을 포함해야 합니다.

## 제 2정규형(2NF)

함수 종속성

- 한 테이블에 중복되는 값이 많이 있을 때 테이블을 분리한다.
- ~~한 칼럼이 다른 칼럼의 값에 의존할 때~~

## 제 3정규형(3NF)

어떤 속성도 기본 키에만 직접적으로 종속되어야 한다. + 다른 non-key 속성에 의존해서는 안 됨!

# SQL

데이터베이스 언어

## DCL

사용자에게 권한 부여

### JOIN

테이블 결합

- inner-join : 실로 사용되기로는 그냥 조인
- left-join : 조인 조건에 만족하는 오른쪽 칼럼만 조인 (없으면 null)
- right-join
- outer-join
- 프라우터 조인: 모든 레코드 포함하고 조인 조건에 만족하지 않으면 ㄴㄴ (mySQL에서 직접 지원 ㄴㄴ)

<단>

잘못된 조인은 성능 저하

### VIEW

데이터 보는 방식 제공.

실제로 저장된 테이블은 아니고, 쿼리 결과가ㅏ 테이블처럼 제공된다.

UNION

sql 쿼리문으 ㅣ결과를 합침

# erd

디비 안에 한 눈에 파악할 수 있도록 도와주는 도구

<aside>
📌

엔티티

</aside>

### 오늘의 회고
- 

### 참고 자료 및 링크

