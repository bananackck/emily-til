# Spring MVC, Bean, DI, IoC

## 날짜: 2025-03-10

### 스크럼
- 학습 목표 1 :

### 오늘의 도전 과제와 해결 방법
- 

### 새로 배운 내용
spring mvc

스프링 프레임워크에서 mvc 패턴을 제공하기 위해 만들어진 모듈

유연하고 확장성이 높다 → 이유: 확장 상속, 커스텀 하고 싶을 때 나누어저 있는 클래스에서 할 수 있다?

- dispatcherservlet : 모든 api 요청을 가장 먼저 받아서 처리
    - 요청 흐름을 앞단에서 받아서 처리
- handlermapping: 컨트롤러를 **찾아주고** 매핑
- hanleradapter : 찾은 컨트롤러르 실행할 수 있도록 도와주는 역할
- (viewresolver) : 화면을 반환

뷰리졸버 반환하지 않고 json 응답하는 경우 → restcontroller 쓰는 경우. 

⇒ httpmessageconverter 사용해서 응답한다.

인터셉터 : 인증 인가

필터 : 인터셉터에서 더 앞단에서 요청 처리

# Bean

- **스프링 컨테이너에 의해 관리되는 컴포넌트**
- 별도의 예약어(설정 메타 정보)로 정의됨 (ex. @Bean)
- 재사용 가능한 컴포넌트
- DI (의존성 주입) 대상

<aside>
🎀

DI

컴포넌트 간의 결합도를 낮추어 **적정 수준의 의존성 관리**를 가능하게 해줌

</aside>

<aside>
🎀

**의존성**

(dependency)

강한 결합

(Tight Coupling)

</aside>

빈은 클래스에 어노테이션(@)을 붙여서 Bean이라고 등록하는 것이다. 

**인스턴스가 Spring IoC 컨테이너에 의해 생성, 관리되고 의존성 주입 등의 기능을 적용받는 것을 의미**

모든 빈은 인스턴스이지만, 모든 인스턴스가 빈은 아닙니다. 빈은 Spring 컨테이너에 등록된 특별한 인스턴스라고 생각하면 됩니다

## 사용 방법

1. **빈 정의:** ~~XML 설정 파일 (`<bean>`),~~ 클래스 레벨 어노테이션 (`@Component`, `@Service`, `@Controller`, `@Repository`), 또는 Java Config (`@Configuration`, `@Bean`) 등을 사용하여 빈을 정의합니다. 빈의 클래스 정보, 초기화/소멸 메서드, 의존 관계 등을 설정 정보에 명시합니다.
2. **스프링 컨테이너에 등록:** 정의된 빈 설정 정보를 스프링 컨테이너에게 전달하여 빈을 컨테이너에 등록합니다. 컨테이너는 설정 정보를 기반으로 빈을 생성하고 관리합니다.
3. **빈 획득 및 사용:** `ApplicationContext` 와 같은 스프링 컨테이너 API 를 통해 필요한 빈을 획득 (`getBean()`) 하여 애플리케이션 코드에서 사용합니다. **주로 의존성 주입 (DI) 을 통해 빈을 주입받아 사용하는 것이 일반적**입니다.
    1. `getBean()` 사용 거의 ㄴㄴ

## 빈의 스코프

1. **singleton(기본 스코프)**
    - 애플리케이션 전체에서 단 **하나**의 객체 인스턴스만 유지
    - 공유 객체로 사용됨. 애플리케이션 시작시 정의됨
    - 상태를 유지할 필요가 없을 때 (ex. 유틸리티 클래스, 디비 클래스)
    - 상태 값을 가지지 않도록 해야한다.
2. prototype 
    - **요청할 때마다 새로운** 인스턴스 생성(→ DI 받을 때)
    - 상태를 가지는 객체를 매번 새롭게 필요로하는 경우.
3. Request
    - HTTP 요청 하나 당 하나의 빈 인스턴스 생성 & 요청이 끝나면 소멸
    - http 요청 있을 때마다 생성
    - web application context 안에서만 돌아간다
    - 일반적인 spring application context에서 사용 될 수 없다
    - http 요청이 있을 때마다 생성되니까 의존성이 있으면 문제가 된다. 그래서 프록시 사용이 필요하다
    
    ```java
    @Scope(value="request", proxyMode=ScopedProxyMode.INTERFACES)
    ```
    
4. Session
    - HTTP 세션 당 하나의 빈 인스턴스
5. GlobalSession
    - 

## 빈의 생명주기

1. bean 생성
2. DI 
3. 초기화’
    - 빈의 속성 확인, aop 적용, 외부 리소스 미리 로딩, 캐시 초기화
4. 사용
5. 소멸

# IoC

(Inversion of Control)

스프링 프레임워크에서만 사용되는건 아님  ⇒ 디자인 철학임.(개념이자 원리로만 존재)

- **객체에 대한 제어 권한**이 기존의 **개발자**에서 **스프링 IoC 컨테이너**로 **역전**되는 **디자인 원리 혹은 개념**

- 객체 제어 권한 역전 : 객체(Bean) 생성, 의존 관계 설정, 생명주기 관리 등의 관리가 개발자가 안해도 됨. 개발자는 비즈니스 로직에 더 집중할 수 있음
- 프레임워크가 객체 관리: 저 위의 관리를 프레임워크가 함
- 코드 결합도 감소: 객체 간의 의존 관계를 스프링 컨테이너가 어느정도 관리→ 결합도 낮춤
- 모듈화 및 재사용성 증대
- 테스트 용이성 향상 : 단위 테스트 수행 용이

# DI

(Dependency Injection)

IoC를 실제로 구현하는 방법

객체가 필요로 하는 의존 객체를 외부에서 주입받는 방식

@SpringBootApplication

이 어노테이션이 붙어있으면 자동으로 쭉쭉 알아서 만들고 실행하고 생성하고 한여 IoC를 만족한다.

빈을 쫙 깔아놓고 의존성 주입이 실행된다.

## Spring IoC 컨테이너의 인터페이스 종류

1. BeanFactory(거의 사용 ㄴㄴ)
    - 실제로 객체가 필요할 때 생성
    - AOP, 메시지 처리, 국제화(i18n) 등은 제공 ㄴㄴ
    - ApplicationContext의 부모 인터페이스
2. ApplicationContext
    - AOP, 메시지 처리, 국제화(i18n) 등 제공
    
    | 특징 | 설명 |
    | --- | --- |
    | **IoC 컨테이너 구현체** | `BeanFactory` 인터페이스를 확장하여 다양한 부가 기능(AOP, 메시징, 국제화 등)을 제공하는 IoC 컨테이너입니다. |
    | **빈 생명주기 관리** | 빈의 생성, 초기화, 소멸 등 전체 생명주기를 종합적으로 관리합니다.
    빈스코프 관리, BeanPostProcessor 관리 기능 제공 |
    | **빈 설정 로딩 및 관리** | XML, 어노테이션, Java Config 등 다양한 설정 방식을 지원하며, 설정 정보를 로딩·관리하는 기능을 제공합니다. |

azure에서는 XML 설정을 직접 해줘야 하는데 springBoot는 호출 시 내부적으로 **적절한 ApplicationContext**를 자동 생성하고 초기화하여 XML 설정도 자동으로 된다.

# DI

(Dependency Injection)

객체가 필요로 하는 의존 객체를 직접 생성하지 않고, 외부에서 주입받는 원리 혹은 기법

→ 자신의 본 로직에만 집중할 수 있다.

⇒ DI는 결국 IoC를 달성한다.

- 의존 객체를 외부에서 주입 (ex. 스프링 컨테이너…)
- 객체 간 결합도 감소
    
    <aside>
    🎀
    
    DIP 원칙
    
    (Dependency Injection Principle)
    
    1. 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.
        - 비즈니스 로직 등은 세부 구현에 직접 의존하지 않고, 둘 다 **추상화(인터페이스나 추상 클래스)**에 의존해야 함.
    2. 추상화는 세부 사항에 의존해서는 안된다.
        - 세부 사항은 추상화에 의존해야 한다.
    
    ⇒ 고수준 모듈과 저수준 모듈 모두 추상화에 의존하도록 유도하여 모듈 간의 결합도를 낮추는 원칙
    
    → 코드의 유연성과 확장성, 테스트 용이성 🆙
    
    </aside>
    
- 인터페이스 기반 설계 장려 : 코드 작성 영역이 최소화됨, 인터페이스 객체간의 약속 역할
- 테스트/재사용성 향상

## ⭐DI 구현 방식!! 매우매우 중요!!

1. **👍생성자 주입**(가장 권장!)
    - 안정적인 객체 생성 보장 & 불변성을 지키기도 수월함(final 필드를 같이 사용하면)
    - 순환 참조(a→b 의존, b→a 의존) 예방
2. setter 주입
    - 필수 의존성 강제 ㄴㄴ
3. 필드 주입

---

# Annotation

= 컴파일러와 개발자에게 추가적인 정보를 제공하는 메타데이터

프로그램 코드의 일부가 아닌, 프로그램에 관한 데이터를 제공하고, 코드에 정보를 추가하는 정형화된 방법

<사용 이유>

1. **컴파일러 체크**
    
    예를 들어, `@Override`를 붙이면 컴파일러가 해당 메서드가 상위 클래스나 인터페이스의 메서드를 올바르게 오버라이딩 하고 있는지 검사
    
    오타나 시그니처가 틀릴 시. 컴파일 오류를 발생
    
2. **가독성 및 문서화**
    
    코드의 의도를 명확하게 표현하여 역할을 바로 알 수 있음
    
    → 유지보수와 협업에 도움이 됨
    
3. **부가 기능 제공**
    
    Spring, JPA 등 다양한 프레임워크에서는 어노테이션을 활용하여 런타임에 객체를 자동으로 생성하거나 특정 동작을 수행하도록 함
    
    → 코드를 간결하게 유지 & 복잡한 설정이나 동작을 자동화
    

어노테이션에는 굉장히 많은 종류가 있다. 그 중 잘 쓰이는 몇 가지를 알아보자.

### @override

메서드가 슈퍼클래스(또는 인터페이스)의 메서드를 재정의(override)하고 있음을 컴파일러에 알려줌

---

### @SpringBootApplication

Srping Boot를 자동으로 실행시켜주는 어노테이션

Bean을 정의하고 등록하는 3가지 어노테이션을 포함한다.

- **@Configuration**: 해당 클래스가 Spring 설정 파일임을 선언합니다.
- **@EnableAutoConfiguration**: 미리 정의된 설정들을 바탕으로 자동으로 Bean들을 등록해줍니다.
- **@ComponentScan**: 지정된 패키지(기본적으로 현재 클래스가 위치한 패키지 및 하위 패키지) 내의 컴포넌트를 검색하여 Bean으로 등록합니다.

<aside>
🎀

Spring 설정 파일

= Bean을 정의 & 구성

- XML 설정 파일(구 방식)
    - 스프링 컨테이너에게 어떤 빈들을 어떻게 생성하고 연결할지를 알려주는 설정 리소스
- Java Config(최신 방식)
    - `@Configuration`과 그 안의 `@Bean` 메서드들을 사용하면, 해당 메서드들이 반환하는 객체들이 bean으로 등록됨
</aside>

### @ComponentScan

직접 작성한 class를 bean으로 등록

→ value를 이용해 bean의 이름을 지정

### @Bean

개발자가 제어 불가한 클래스(ex. 외부 라이브러리)를 bean으로 등록

→ name을 이용해 bean의 이름을 지정

---

### @Controller

Spring MVC의 Controller로 사용되는, 클래스 선언을 단순화 시켜주는 어노테이션

### @RestController

Spring에서 Controller 중 View로 응답하지 않는 Controller를 의미한다.

method의 반환 결과를 JSON 형태로 반환한다.

⇒ @Controller + @ResponseBody

|  | @Controller | @RestController |
| --- | --- | --- |
| **역할** | View와 API를 모두 처리하는 컨트롤러 | API 전용 컨트롤러 (데이터만 반환하며, View는 처리 X) |
| **응답 형태** | 기본적으로 View(HTML 등)를 반환하며, API일 경우 별도로 @ResponseBody 사용 필요 | 메서드의 반환 값을 JSON이나 XML 등으로 직접 HTTP Response에 담아 반환 (자동 @ResponseBody 적용) |
| **사용 목적** | 웹 애플리케이션에서 UI 렌더링과 API를 함께 사용할 때 | RESTful API 개발 시, View가 필요 없는 데이터 응답에 사용 |

### 오늘의 회고
- 

### 참고 자료 및 링크

