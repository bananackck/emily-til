# HTTP 자격증명 헤더, JWT token, OAuth

## 날짜: 2025-02-13

### 스크럼
- 학습 목표 1 : 과제 3 시작하기

### 새로 배운 내용
# HTTP 자격증명 헤더

클라이언트와 서버 간의 인증과정에서 사용자의 자격을 확인하기 위해 사용되는 헤더

<aside>
💡

헤더?

문지기

</aside>

- WWW-Authenticate   :  서버가 클라이언트에게 인증 요청
- Authorization               :  클라이언트가 서버에게 자신을 인증함

<중요성>

- 웹 리소스에 접근할 때 필요한 사용자의 인증 정보를 서버에 전달하기 위해서

<동작 방식>

HTTP Authorization 헤더에 인코딩된 인증 정보를 담아 요청과 함께 서버로 전송

<인증 방식>

- 기본 인증
- 다이제스트 인증
- Bearer XHZMS
- OAuth

⇒ 성공하면 200 페이지 안되면 400 페이지 리턴함

## 기본 인증(Base Authentication)

(옛날꺼)

base64 인코딩:  암호화 되지 않은 인코딩

- 테스트 환경에서 많이 사용
- 보안 취약 - HTTPS와 같이 사용하기

## 다이제스트 인증(Digest Authentication)

(옛날꺼)

비밀번호의 해시된 값을 전송하여 인증 수행

ex)

WWW-Authenticate: Digest realm="ExampleRealm", nonce="...", algorithm=MD5, qop="auth”

<동작 방식>

1. 클라이언트에게 인증 요청  :  서버는 401 Unauthorized 응답과 WWW-Authenticate 헤더를 같이 보냄. nonce, realm 포함
    
    <aside>
    💡
    
    **nonce**
    
    (Number Used Once)
    
    서버에 의해 임의로 생성되는 숫자
    
    ---
    
    **realm**
    
     사용자에게 어떤 영역이나 자원에 대해 인증이 요구되고 있는지 알려주는 문자열
    
    </aside>
    
2. 클라이언트의 응답 생성
    
    해시 함수를 사용해 응답 생성
    
    <aside>
    💡
    
    **해시 함수**
    
     ****임의의 길이를 가진 데이터를 입력받아 고정된 길이의 값, 즉 해시값을 출력하는 함수
    
    ex) MD5(Message-Digest Algorithm 5)
    
    근데 별로 안전하진 않음
    
    </aside>
    
3. 서버에서 인증 처리

## 베어러 토큰(Bearer Token)

사용자 인증을 위한 보안된 텍스트 문자열 형태의 토큰

<동작 방식>

1. 토큰 획득
    
    서버로부터 액세스 토큰 받음(접근 권한)- JWT 토큰 형태태
    
2. 토큰을 이용한 요청
3. 서버에서 인증 처리

<단점>

토큰 탈취 당하면 끝

→ 강화하기 위해서 리프레시 토큰을 쓰거나, 시간 설정함

# JWT

(JSON Web Token)

<aside>
💡

**Json**

자바스크립트 객체 문법으로 구조화된 데이터를 표현하기 위한 문자 기반의 표준 포맷

</aside>

애플리케이션 사이의 정보 교환을 위해 설계되어 정보를 JSON 형식으로 포함하는 자체 포함형 토큰

<aside>
💡

**자체 포함형**

(compact and self-contained)

모든 필요한 정보를 자체적으로 담고 있다. 헤더, 페이로드, 화면

별도의 추가 DB 조회 없이도 인증이나 권한 확인 가능

</aside>

<중요성>

- 무상태 인증(Stateless Authentication) : 토큰 자체에 정보가 다 담겨 있어서 서버가 세션 데이터 관리 ㄴㄴ  →  서버 부담 줄음, 애프리케이션 확장성 늘어남
- 서버 간의 부담 감소
- 안정적인 확정성
- 보안과 데이터 무결성 보장
- 유연성과 다양한 적용 가능성

<사용 방법>

### 1. 토큰 발급

사용자가 아이디, 비밀번호, 소셜로그인 로그인 성공하면 서버에서 JWT를 생성해서 클라이언트에게 발급한다.

1. 사용자 인증
    1. 서버가 클라이언트로 전달받은 인증정보(아이디, 비밀번호)를 검증
2. Payload 생성
    1. JSON 형식 데이터, 토큰 안에 들어갈 내용을 정의함
        1. 필수 클레임 - 토큰 유효성 검증 및 관리를 위한 데이터(토큰 발급자, 토큰 제목, 토큰 대상, 만료 시간, 활성 시간, 발급 시간)
        2. 공개 클레임 - 자유롭게 정의 할 수 있는 클레임
        3. 비공개 클레임 - 토큰 발급자랑 수신자만 알고 있는 클레임(사용자 아이디, 이름, 권한 정보)
        
        <aside>
        💡
        
        클레임?
        
        </aside>
        
3. 헤더 생성
    1. JSON 형식 데이터
    2. 토큰 유형 : JWT
    3. 서명 알고리즘 : HMAC, SHA256
4. 서명(Signature) 생성
    1. Header, Payload 기반으로 Base64 인코딩 후 비밀키를 사용해서 생성
5. JWT 발급
    1. Access Token, Refresh Token
    2. 

### 2. 토큰 전송

클라이언트는서버로부터 발급받은 JWT 토큰을 저장 & 보호된 리소스 접근할 때마다 서버에 전송

1. Authorization Header : Bearer 스키마  → 표준방식, restful
    
    <단>
    
    CORS 문제가 발생할 수도 있다.
    

### 3. 토큰 검증

서버가 클라이언트로부터 JWT 토큰을 받으면 유효한지 검증

1. JWT 추출
    1. Authorization Header, Cookie에서 추출
2. JWT 파싱
    1. Base64로 디코딩해서 Header, Payload, Signature을 분리
3. 서명 검증
    1. Header에 명시된 alg와 비밀키를 사용해서 서명 검증
    2. 클라이언트로부터 받은 서명과 서버가 생성한 서명을 비교해서 토큰 위변조 여부 확인
4. 클레임 검증
    1. 만료시간, 토큰 발급자, 토큰 대상 유효성 검사
5. 인증 성공/실패

### 4. 권한에 따른 처리

서버는 JWT payload에 포함된 사용자 정보, 권한을 통해서 인가 처리

- Role-Based Access Control - RBAC
    
    역할 기반 접근 제어 방식. 
    
    payload에 담겨 있는 사용자 역할 정보를 기반으로 인가 처리
    
- Attribute-Based Access Control - ABAC
    
    속성 기반 접근 제어 방식.
    

## JWT와 세션 혼합 구현 방식

JWT 토큰이랑 세션 둘 다 사용 함

- JWT를 사용하여 초기 인증 → 파생된 세션 정보(로그인 상태 유지를 위한 최소한의 정보만)를 서버에서 관리

# OAuth

<과정>

1. 인증 요청
    1. 클라이언트 인증 서버에게 요청
2. 인증 및 코드 발급
    1. 인증 서버가 사용자를 인증 - 구글, 페이스북 로그인
    2. 인증 코드를 발급
3. 토큰 교환
    1. 클라이언트 인증코드를 accecc Token으로 교환
4. 리소스 접근
    1. 클라이언트 Access token 리소스 서버에 API Call 하거나 정보요청할 수 있다.



### 오늘의 도전 과제와 해결 방법
- 

### 오늘의 회고
- 

### 참고 자료 및 링크

