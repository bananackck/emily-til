# 쿠키, 스토리지, 세션

## 날짜: 2025-02-17

### 스크럼
- 학습 목표 1 : 쿠키, 스토리지, 세션

### 새로 배운 내용
#### 쿠키란
인터넷 사용자가 웹 사이트를 방문할 경우   
사이트가 사용하고 있는 서버를 통해   
인터넷 사용자의 컴퓨터에 설치되는 **작은 기록 정보 파일**  
→ **개인화된 서비스를 제공**  

<종류>
1. 퍼스트파티 쿠키
방문 중인 웹사이트의 도메인에서 설정한 쿠키  
→ UX 편리하게 하기 위해  
2. 서드파티 쿠키
방문 중인 웹사이트의 도메인과 다른 도메인에서 설정한 쿠키  
ex) 광고 베너  
→ 상업적 사용

```jsx
// 쿠키 설정 함수
const setCookie = (name, value, days) => {
    let expires = "";
    if (days) {
        const date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000)); // 시간*분*초*밀리초
        expires = `; expires=${date.toUTCString()}`;
    }
    // 예) username=void; expires=Wed, 30 Oct 2024 12:00:00 GMT; path=/
    document.cookie = `${name}=${value || ""}${expires}; path=/`;
};

// 쿠키 가져오기 함수
const getCookie = (name) => {
    const cookies = document.cookie.split('; ');
    ...
};
```

#### 쿠키 유효시간
| **구분** | **설명** | **설정 예시** |
| --- | --- | --- |
| **Persistent Cookie** | 유효시간이 명시 & 브라우저를 닫아도 삭제 X → **`MaxAge`** / **`Expires`**  | `username=void; expires=Wed, 30 Oct 2024 12:00:00 GMT; path=/` |
| **Session Cookie** | 유효시간이 명시 X & 브라우저가 닫히면 삭제 → ex) 로그인 유지.. | `session_id=abc123; path=/` |

#### 쿠키의 단점과 해결방안...
1. 보안
→  HttpOnly : XSS 공격으로부터 쿠키 정보 보호  
> **XSS**  
(Cross-Site Scripting)

→ Secure : Https를 통해 데이터를 암호화 중간자 공격 방지  
> **중간자 공격?**  
(MITM(Man In The Middle))  
클라이언트와 서버 사이의 통신을 탈취!

→ SameSite : CSRF 공격을 방지하기 위해, 퍼스트파티에서만 쿠키 전송 제한  
> **CSRF**  
(Cross-Site Request Forgery)  
사용자의 의지와는 무관하게 웹 애플리케이션에 공격자가 의도한 요청을 보내도록 유도하는 공격
- Strict
    - 퍼스트파티 쿠키 전송만 허용
- Lax
    - 사이트 직접 방문 혹은 안전한 `GET` 요청에서만 서드파티 허용(ex. 링크 클릭 시만 쿠키 전송 허용)
- None
    - 모든 서드파티 쿠키 허용, 단 https 에서만

2. 브라우저 간 공유 불가(여러 디바이스 X)
→ 세션 등장!   세션 ID를 쿠키로 저장
3. 네트워크 부하 증가

#### 스토리지
데이터를 일시적으로 또는 영구히 보존하는 웹 브라우저 저장소  
- 쿠키보다 용량이 큼  
<종류>
1. **local storage** : 영구적  
    웹 브라우저 닫혀도 지속 / UX 향상 / 저장 용량 관리 필수  
2. **session storage** : 세션 동안  
    웹 브라우저 닫히면 삭제

#### 세션
컴퓨터 프로세스들 사이이에서, 서로를 **인식**한 후 데이터 **송수신**을 마칠 때까지의 기간의 상태 정보.

데이터를 열고 닫는거 까지가 한 세션

- 세션과 쿠키는 같이 쓰이기도 한다

| 기술 | 설명 |
| --- | --- |
| 쿠키의 역할 | 웹 브라우저의 쿠키에는 어떤 세션인지 식별하기 위한 세션 ID(Session ID) 값이 저장되어 있습니다. |
| 세션의 역할 | 세션은 일반적으로 웹 브라우저로부터 세션 ID를 받아 해당 요청 사용자의 정보를 서버 측 저장소에서 조회합니다. |

!!!! 세션 스토리지의 속도 매우 중요!!!!

⇒ redis 많이 사용

<중요성>

- 민감한 정보의 안전한 저장
- 네트워크 오버헤드 감소

<사용 방법>

사용자 별 고유 식별자(세션ID)를 생성해 사용자의 정보를 저장하고, 브라우저는 이 세션ID를 사용해서 서버와 통신

- 로그인 세션
    - 사용자가 로그인하고 로그아웃할 때까지 지속됨
- HTTP 세션
    - HTTP 연결 동안 지속됨
- 브라우저 세션
    - 브라우저 탭/창이 열려 있는 동안 지속됨

<세션 저장 방식>

- in memory
    - 코드로(변수에) 세션 저장
    
    → 세션 상태 동기화가 안됨….
    
- file storage
    - 파일을 생성해서 txt로 저장
    
    → 파일 입출력이 오버헤드 많이 발생…
    
- database
    - 디비에 저장
    
    → 안정적 & 세션 동기화 가능
    
    → db 오버헤드 발생 & 어려움

#### 쿠키와 세션의 차이
|  | **COOKIE** | **SESSION** |
| --- | --- | --- |
| 정의 | = 서버에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일 | = 방문자가 웹 서버에 접속해 있는 상태 |
| 저장 위치 | 클라이언트 PC | 서버 |
| 보안성 | - 👎보안 취약(클라이언트에 저장되니까….) | - 👍(비교적) 보안 굿 |
| 용량 | - ⬇️용량 작음(4KB) | - ♾️용량 제한 거의 X |
| 만료 기간 | - 만료 기간 설정 가능 | - 브라우저 종료 시 삭제 |
| 속도 | - 📈빠름 | - 📉비교적 느림(서버에 정보가 저장…) |
| 동작 순서 | 1. 클라이언트가 서버에 페이지 요청 | 1. 클라이언트가 서버에 페이지 요청 |
|  | 2. 웹 서버가 쿠키 생성 | 2. 서버는 클라이언트의 Cookie를 확인하여, 해당 session-id를 보냈는지 확인 |
|  | 3. 생성한 쿠키에 정보를 담아 HTTP 화면을 돌려줄 때, 같이 클라이언트에게 전달 | 3. session-id 없으면 생성해 보냄 |
|  | 4. 클라이언트는 쿠키를 로컬PC에 거장 후 서버에 요청할 때, 요청과 함께 쿠키 전송 | 4. 클라이언트는 session-id를 쿠키에 저장 |
|  | 5. 재방문 시 로컬PC에 쿠키 있으면, 페이지와 쿠키 함께 전송 | 5. 클라이언트는 서버에 요청시 이 쿠키의 session-id 값을 같이 서버에 전달 |
|  |  | 6. 서버는 받은 session-id로 session에 있는 클라이언트 정보를 가지고 요청 처리 후 응답. |


### 오늘의 도전 과제와 해결 방법
- 

### 오늘의 회고
- 

### 참고 자료 및 링크
[쿠키와 세션의 차이](!'https://dev-coco.tistory.com/61')
