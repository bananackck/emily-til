# 공유자원, 임계영역, 동기화, LOCK

## 날짜: 2025-02-10

### 스크럼
- 학습 목표 1 :

### 오늘의 도전 과제와 해결 방법
- 

### 새로 배운 내용
# 공유 자원

(Shared Resource)

여러 스레드나 프로세스가 동시에 접근하거나 사용하는 시스템 내의 자원

- 파일 시스템: 읽기/쓰기
- 네트워크 프린터
- 메모리
- 데이터베이스

<사용 이유>

- 리소스 낭비 방지 &  효율성 극대화
- 협업 하기!

# 임계 영역

(Critical Section)

공유 자원에 접근하는 프로그램 코드의 일부

<사용 이유>

- 데이터 무결성 유지
    
    임계 영역에서 한 번에 하나의 스레드/프로세스가 실행되도록 보장하여, 공유 자원의 데이터 보장
    
- 경합 조건(Race Condition) 방지

# 동기화

동기화는 여러 작업(스레드 또는 프로세스)이 **공유 자원에 동시에 접근할 때 발생할 수 있는 충돌이나 데이터 무결성 문제를 방지**하고, 작업의 일관성을 보장하기 위한 기술

| 특징 | 설명 |
| --- | --- |
| **순서 보장** | 여러 작업이 자원에 접근할 때 순서를 조정하여 충돌을 방지. |
| **공유 자원 보호** | 동기화 기술로 공유 데이터의 무결성을 유지. |
| **경합 문제 해결** | 자원 접근이 동시에 이루어질 경우 데이터 손상을 방지. |

<중요성>

- 데이터 무결성 손실 = 여러 스레드/프로세스가 동시에 데이터 수정 시 이상한 값 저장 될 수 있음
- 데이터 경합(Race Condition) = 실행 순서에 따라 결과 예측 불가능
- 데드락 = 무한 대기 → 서로가 서로를 기다림

### 임계 영역 문제 해결 조건(=동기화가 됨을 보장)

1. Mutual Exclusion (상호 배제)
    
    하나의 프로세스가 임계 영역에서 실행 중일 때, 다른 프로세스는 임계 영역에 들어갈 수 없다.
    
2. Progress (진행)
    
    경쟁 프로세스가 없을 때, 즉시 실행이 가능해야 함. (불필요한 대기 줄임)
    
3. Bounded Waiting (유한한 대기)
    
    대기 중인 프로세스는 언젠가는 실행 되야 함
    

<동작 방식>

1. **Lock/Mutex**
2. **Semaphore**
3. **Condition Variable**

### Lock/Mutex

자원에 대한 배타적 접근을 보장

→ 단일 자원 보호

### Condition Variable

특정 조건이 충족 될 때까지 대기 후 신호로 재개

### Semaphore

허용량 설정으로 동시 접근을 제한

→ 다중 자원 접근 제어

# Lock

하나의 프로세스/스레드가 자원을 점유할 경우 다른 게 해당 자원에 접근하지 못하도록 제어하는 **기법**

<aside>
💡

! 너무 보수적인 LOCK은 성능 저하를 초래한다.

</aside>

<동작 방식>

1. 공유 자원 대기 상태 : 아무도 접근 요청 ㄴㄴ
2. Thread 1의 락 요청
3. Thread 1의 락 점유 및 작업 수행
4. Thread 2의 락 요청
5. Thread 2의 대기
6. Thread 1 작업 완료 및 락 해제
7. Thread 2의 락 요청
8. Thread 2의 락 점유

<락의 종류>

- 스핀락(Spin Lock)
    
    락이 해제될 때까지(5에서) **계속해서 반복적으로 락 상태를 확인**
    
    → 락이 해제될 떄까지의 시간이 짧으면 thread sleep→awake 보다 효율적
    
    - **짧은** 임계 영역 보호에 사용
    
    긴 임계 영역 보호 (ex) 디비 접근)
    
- 낙관적 락(Optimistic Lock)
    
    데이터 충돌이 드물다고 가정하고 락 없이 수행 후, 충돌 발생 시 **롤백**
    
    = **락 사용 안함**
    
    → 데이터 충돌이 드뭄이 보장된 경우에 사용
    
    - 락보다 빠름 (ex) sns…)

- 뮤텍스(Mutex)
    
    내가 락을 소유하면 나만 락을 해제할 수 있다
    
    thread를 sleep→awake(CPU 낭비 ㄴㄴ)
    
    - **긴** 임계 영역 보호에 사용
    - 조건 변수와 같이 사용 됨
    
    (바이너리 세마포어랑 비슷하게 사용됨)
    

- 리드-라이트 락(Read-Write Lock)
    
    읽기 작업(동시에 자원 접근 가능)과 쓰기 작업(자원 독점)을 구분하여 락을 관리
    
    - read : 데이터 읽기
    - write : 데이터 쓰기, 수정, 삭제 …
    
    → read lock이 하나라도 점유 중일 때는 write lock은 대기 해야 함
    
    → write lock이 점유 중일 때는 read lock은 대기 해야 함
    
    (ex) 캐시 관리 할 때 굿)

### 오늘의 회고
- 

### 참고 자료 및 링크

